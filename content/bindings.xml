<?xml version="1.0"?>

<bindings id="messageBindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:html="http://www.w3.org/1999/xhtml"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="query">
    <implementation>
      <field name="hitMessageMap">{}</field>
      <property name="glodaQuery">
        <!--The Gloda query object-->
        <getter>
            <![CDATA[
            return this.query;
            ]]>
        </getter>
        <setter>
        <![CDATA[
        try {
            this.query = val;
            let constraints = val._constraints;
            let constraintsNode = document.getAnonymousElementByAttribute(this,
                                                      'anonid', 'constraints');
            while (constraintsNode.firstChild)
              constraintsNode.removeChild(constraintsNode.firstChild);

            for (let i = 0; i < constraints.length; i++) {
              let constraint = constraints[i];
              let constraintNode = document.createElement('div');
              constraintNode.setAttribute('class', 'constraint');
              constraintNode.textContent = constraint.toString();
              constraintsNode.appendChild(constraintNode);
            }
            // XXX waiting until refactoring to do it right, as the
            // constraints should be easier to explain to the user then.
        } catch (e) {
           dumpExc(e, 'query');
        }
        ]]>
        </setter>
      </property>
      <method name="addItems">
        <parameter name="items"/>
        <body>
        <![CDATA[
        try {
          // We want to keep track of which messages were found in the query
          // and of the conversations that they belong to.  The former
          // will be displayed in the latter with special styling, etc.
          let conversationMap = this.conversationMap = {};
          let conversationsNode = document.getElementById("conversations");
          this.hitMessageMap = {};
          let conversations = this.conversations = [];

          // XXX TBD: we should have the messages sorted w/ most recent first,
          // that way we'll have 'free' sorting of the conversations.
          // In general, we probably want something smarter to figure out
          // most relevant conversations first, but recency is a good first cut.
          
          for each (let message in items) {
            this.hitMessageMap[message.id] = true;
            let conv = message.conversation;
            if (!(conv.id in conversationMap)) {
              let convInfo = {conv: conv, hits: [message]};
              conversationMap[conv.id] = convInfo;
              conversations.push(convInfo);
            }
            else {
              let convInfo = this.conversationMap[conv.id];
              convInfo.hits.push(message);
            }
          }
          conversationsNode.setAttribute("hidden", "true");
          let convcount = 0;
          for (let i in conversations.slice(0, 20))
          {
            convcount++;
            let convInfo = conversations[i];
            let conv = convInfo.conv;
            let convid = 'conv'+conv.id.toString();
            let node = document.getElementById(convid);
            if (!node) {
              node = document.createElementNS("http://www.w3.org/1999/xhtml", "conversation");
              conversationsNode.appendChild(node);
              node.id = 'conv' + conv.id.toString()
              node.setAttribute("tabindex", convcount);
              node.glodaConversation = conv; // XXX this is _slow_
              convInfo.messagesColl = node.messageCollection;
            }
          }
          conversationsNode.removeAttribute("hidden"); // XXX the consequences of this are _slow_
          dump("conversations shown\n");
        } catch (e) {
          dumpExc(e);
        }
        ]]>
        </body>
      </method>
      <method name="modifyItems">
        <parameter name="items"/>
        <body>
          <![CDATA[
          ]]>
        </body>
      </method>
      <method name="removeItems">
        <parameter name="items"/>
        <body>
          <![CDATA[
          ]]>
        </body>
      </method>
    </implementation>
    <content>
      <html:div class="query">
        Search of <html:div class="scope">All Messages</html:div>
        <html:div class="constraints" anonid="constraints"></html:div>
        <!--<html:div class="involves" anonid="involves"></html:div>-->
        <!--<html:div class="involves" anonid="involves"></html:div>-->
        <!--<html:div class="mentioning" anonid="mentioning"></html:div>-->
        <html:div xbl:inherits="class=divclass" anonid="name"></html:div>
      </html:div>
    </content>
  </binding>

  <!-- a query that visualizes stuffs -->
  <binding id="vis-query"
           extends="chrome://experimentaltoolbar/content/bindings.xml#query">
    <implementation>
      <method name="addItems">
        <parameter name="items"/>
        <body>
        <![CDATA[
        try {
          // call the superclass method, why not
          this.__proto__.__proto__.addItems(items);

          let visNode = document.getElementById("vis");

          this.radarVis = makeConversationRadarVis(visNode,
            this.conversations);
          this.radarVis.vis.render();
        }
        catch (e) {
          dumpExc(e);
        }
        ]]>
        </body>
     </method>
    </implementation>
  </binding>

  <binding id="search-toolbox">
    <implementation>
      <method name="junkSelectedConversations">
        <body><![CDATA[
          try {
            let conversationNodes = Iterator(gSelectedConversationNodes);
            let num = 0;
            for each ([id,conversationNode] in conversationNodes) {
              // iterate over messages in each conversation
              dump("id = " + id + '\n');
              dump("conversationNode = " + conversationNode + '\n');
              let conversation = conversationNode.glodaConversation;
              dump("would be junking conversation: " + conversation + '\n');
              // conversation.junk(); XXX TBD
              conversationNode.dissappear();
              num++;
            }
            this.highlightNotification(num.toString() + " conversations deleted");
          } catch (e) {
            dumpExc(e);
          }
          ]]>
        </body>
      </method>
      <method name="deleteSelectedConversations">
        <body><![CDATA[
          try {
            ddumpObject(gSelectedConversationNodes, "selected", 0);
            let conversationNodes = Iterator(gSelectedConversationNodes);
            let num = 0;
            for each ([id,conversationNode] in conversationNodes) {
              // iterate over messages in each conversation
              let conversation = conversationNode.glodaConversation;
              dump("would be deleting conversation" + conversation + '\n');
              // conversation.delete_(); XXX TBD
              conversationNode.dissappear();
              num++;
            }
            this.highlightNotification(num.toString() + " conversations deleted");
          } catch (e) {
            dumpExc(e);
          }
          ]]>
        </body>
      </method>
      <method name="highlightNotification">
        <parameter name="message"/>
        <body><![CDATA[
          try {
            let infoNode = document.getAnonymousElementByAttribute(this, "anonid", "info");
            infoNode.textContent = message;
            // for theming, we should actually move jquery code that hard-codes
            // colors into a theme-specific JS file.
            $(infoNode).animate( { backgroundColor:"#FDFD9B", color: "#000000" }, { queue:true, duration:200 } )
              .animate( {backgroundColor: "#eaf3fa", color: "#666" }, {duration: 2000 });
          } catch (e) {
            dumpExc(e);
          }
          ]]>
        </body>
      </method>
    </implementation>
    <content>
      <html:div class="toolbar">
        <!--<html:button tabindex="-1" class="archive"><html:u>A</html:u>rchive</html:button>-->
        <html:button tabindex="-1" class="delete"
                     onclick="document.getBindingParent(this).deleteSelectedConversations()"
                     ><html:u>D</html:u>elete</html:button>
        <html:button tabindex="-1" class="junk"
                     onclick="document.getBindingParent(this).junkSelectedConversations()"
                     ><html:u>J</html:u>unk</html:button>
        <html:button tabindex="-1" type="menu">other actions &#8744;</html:button>
      </html:div>
      <html:div class="notifications">
        <html:div anonid="info" class="info">Use tab to navigate conversations</html:div>
      </html:div>
    </content>
  </binding>

  <binding id="identity">
    <implementation>
      <property name="glodaIdentity">
        <!--The GlodaIdentity -->
        <getter>
            <![CDATA[
            return this._identity;
            ]]>
        </getter>
        <setter>
        <![CDATA[
        try {
            this._identity = val;
            if (!val) {
              dump("ERROR: Setting something false to identity");
              throw("Bad identity");
            }
            if (val.contact == parent.parent.Gloda.myContact) {
              this.textContent = "you"; // localize XXX
            } else {
              this.textContent = makeFriendlyName(val.contact.name);
            }
        } catch (e) {
           dumpExc(e, 'identity');
        }
        ]]>
        </setter>
      </property>
    </implementation>
    <content></content>
  </binding>


  <binding id="participation">
    <implementation>
      <method name="addParticipantNode">
        <parameter name="participantsNodeId"/>
        <parameter name="participant"/>
        <parameter name="participantType"/>
        <body><![CDATA[
        try {
          if (!participant) {
            throw("BAD PARTICIPANT");
          }
            let participantNode = document.createElement('identity');
            let participantsNode = document.getAnonymousElementByAttribute(this, "anonid", participantsNodeId);
            participantsNode.appendChild(participantNode);
            participantNode.setAttribute("class", participantType);

            participantNode.glodaIdentity = participant;
        } catch (e) {
          dumpExc(e, "addParticipantNode");
        }
          ]]>
        </body>
      </method>
    </implementation>
  </binding>

  <binding id="message" extends="chrome://experimentaltoolbar/content/bindings.xml#participation">
    <implementation>
      <property name="glodaMessage">
        <!--The GlodaMessage -->
        <getter>
            <![CDATA[
            return this._message;
            ]]>
        </getter>
        <setter>
        <![CDATA[
            this._message = val;
            let id = "msg" + val.id.toString()
            this.setAttribute('id', id);
            this._update();
          ]]>
        </setter>
      </property>
      <method name="_update">
        <body>
        <![CDATA[
        try {
            parent.parent.MsgHdrToMimeMessage(this._message.folderMessage, this, this.addMessageBody)
        } catch (e) {
           dumpExc(e, 'message');
        }
        ]]>
        </body>
      </method>
      <field name="mimeMsg">null</field>
      <method name="addMessageBody">
        <parameter name="msgHdr"/>
        <parameter name="mimeMsg"/>
        <body><![CDATA[
        try {
            this.mimeMsg = mimeMsg;
            this._updateMsgBody();
        } catch (e) {
          dumpExc(e);
        }
        ]]>
        </body>
      </method>
      <method name="_updateMsgBody">
        <body><![CDATA[
        try {
            var snippetNode = document.getAnonymousElementByAttribute(this, "anonid", "snippet");
            let content = parent.parent.Gloda.getMessageContent(this._message, this.mimeMsg);
            let snippet;
            if (content && content.hasContent())
              snippet = content.getContentSnippet(100);
            else
              snippet = findSnippetInMimeMsg(this.mimeMsg);
            if (!snippet)
              snippet = "(blank)";
            snippetNode.textContent = snippet;
            this._message.domContribute(snippetNode);
        } catch (e) {
          dumpExc(e);
        }
        ]]>
        </body>
      </method>
    </implementation>
    <content><html:div class="snippet" anonid="snippet"></html:div></content>
  </binding>  <!--message-->

  <binding id="fullmessage" extends="chrome://experimentaltoolbar/content/bindings.xml#message">
    <implementation>
      <method name="_updateMsgBody">
        <body><![CDATA[
        try {
            let body;
            let content = parent.parent.Gloda.getMessageContent(this._message, this.mimeMsg);
            if (content && content.hasContent())
              body = content.getContentString();
            else
              body = this.mimeMsg.bodyPlain;
            let bodyHTML = makeHTML(body)
            let bodyDOM = stringToDOM(bodyHTML);
            let bodyNode= document.getAnonymousElementByAttribute(this, "anonid", "body");
            try {
              bodyNode.appendChild(bodyDOM);
            } catch (e) {
              dumpExc(e);
            }
            // XXX crashes -- talk to bz about it.
            //bodyNode.innerHTML = "<html:p>foo<html:b>bar</html:b></html:p>";
            this.addParticipantNode('from', this._message.from, 'from');
            let tos = Iterator(this._message.to);
            for (let [indx,to] in tos) {
              this.addParticipantNode('to', to, 'to');
            }
        } catch (e) {
          dumpExc(e);
        }
        ]]>
        </body>
      </method>
    </implementation>
    <content>
      <html:div class="message wrap">
        <html:div class="message details">
          <html:div class="headerblock">
            <html:div class="msgheaders">
              <html:div class="msgheader from"><html:div class="headerlabel">From: </html:div><html:div class="participants from" anonid="from"/></html:div>
              <html:div class="msgheader to"><html:div class="headerlabel">To: </html:div><html:div class="participants to" anonid="to"/></html:div>
            </html:div>
            <html:div class="msgheaders">
              <html:div class="msgheader subject" anonid="subject"></html:div>
              <html:div class="msgheader date" anonid="date"></html:div>
            </html:div>
          </html:div>
          <html:div class="body" anonid="body"></html:div>
        </html:div>
      </html:div>
    </content>
  </binding>

  <!--Replies are follow-on messages in a conversation. -->

  <binding id="reply" extends="chrome://experimentaltoolbar/content/bindings.xml#message">
    <implementation>
      <method name="_update">
        <body>
        <![CDATA[
        try {
            this.addParticipantNode("from", this._message.from, "recipient");

            //let participantNode = document.createElement('identity');
            //let fromNode = document.getAnonymousElementByAttribute(this, "anonid", "from");
            //participantNode.setAttribute("class", "reply from");
            //participantNode.glodaIdentity = this._message.from;
            //parent.parent.MsgHdrToMimeMessage(this._message.folderMessage, this, this.addMessageBody)
            if (this._message.date)
            {
              var date = document.getAnonymousElementByAttribute(this, "anonid", "date");
              date.textContent = makeDateFriendly(this._message.date);
            } else {
              dump("ERROR: No date on this message?\n");
            }
            
            parent.parent.MsgHdrToMimeMessage(this._message.folderMessage, this, this.addMessageBody)
        } catch (e) {
           dumpExc(e, 'reply');
        }
        ]]>
        </body>
      </method>
    </implementation>
    <handlers>
      <handler event="click" preventdefault="true">
        <![CDATA[
          this.parentNode.parentNode.openConversationInTab(this._message);
        ]]>
      </handler>
    </handlers>
    <content>
      <html:div class="author">
        <html:span anonid="from" class="name"></html:span>
        <html:span anonid="date" class="date"></html:span>
      </html:div>
      <html:div anonid="snippet" class="body"></html:div>
    </content>
  </binding>

  <binding id="conversation" extends="chrome://experimentaltoolbar/content/bindings.xml#message">
    <resources>
    </resources>
    <handlers>
      <handler event="keydown" keycode="VK_SPACE" phase="capturing"
               preventdefault="true" action="this.toggleSelect()">
      </handler>
      <handler event="keydown" keycode="VK_RETURN" phase="capturing"
               preventdefault="true" action="this.openConversationInTab()">
      </handler>
      <handler event="keypress" keycode="VK_DELETE" phase="capturing"
               preventdefault="true" action="alert('deleteSelectedConversations()')">
      </handler>
    </handlers>
    <implementation>
      <field name="selected">false</field>
      <property name="glodaConversation">
        <!--This is the GlodaConversation object-->
        <getter>
            <![CDATA[
            return this.conversation;
            ]]>
        </getter>
        <setter>
        <![CDATA[
            this.conversation = val;
            this.selected = false;
            this.messagesCollection =
              this.conversation.getMessagesCollection(this);
        ]]>
        </setter>
      </property>
      <method name="dissappear">
        <body>
        <![CDATA[
        try {
          $(this).slideUp("fast");
          this.unselect();
        } catch (e) {
           dumpExc(e, 'conversation.dissappear');
        }
        ]]>
        </body>
      </method>
      <method name="unselect">
        <body>
        <![CDATA[
        try {
          this.selected = 0;
          if (this.id in gSelectedConversationNodes)
            delete gSelectedConversationNodes[this.id];
        } catch (e) {
           dumpExc(e, 'conversation');
        }
        ]]>
        </body>
      </method>
      <method name="toggleSelect">
        <body>
        <![CDATA[
        try {
          this.selected = ! this.selected;
          // let's make sure that the checkbox matches the state
          let checkbox = document.getAnonymousElementByAttribute(this, "anonid", "checkbox");
          checkbox.checked = this.selected;
          if (this.id in gSelectedConversationNodes)
            delete gSelectedConversationNodes[this.id];
          else
            gSelectedConversationNodes[this.id] = this;
        } catch (e) {
           dumpExc(e, 'conversation');
        }
        ]]>
        </body>
      </method>
      <method name="toggleSelectHelper">
        <body>
        <![CDATA[
        try {
          var e = document.createEvent('MouseEvents');
          e.initEvent( 'click', true, true );
          
          let checkbox = document.getAnonymousElementByAttribute(this, "anonid", "checkbox");
          checkbox.dispatchEvent(e);

        } catch (e) {
           dumpExc(e, 'conversation.toggleSelectHelper');
        }
        ]]>
        </body>
      </method>
      <method name="openConversationInTab">
        <parameter name="messageToSelect"/>
        <body>
        <![CDATA[
        try {
          let tabmail = parent.parent.document.getElementById("tabmail");
          // find what messages we want to highlight
          let hitmap = document.getElementById('query').hitMessageMap
          let searchHits = [];
          for each (let [i,message] in Iterator(this.messages)) {
            if (message.id in hitmap)
            {
              searchHits.push(message);
              if (!messageToSelect)
                messageToSelect = message;
            }
          }
          tabmail.openTab("conversation", [this.conversation], searchHits, messageToSelect);
        } catch (e) {
           dumpExc(e, 'conversation');
        }
        ]]>
        </body>
      </method>
      <method name="openMessageInTab">
        <body>
        <![CDATA[
        try {
          let tabmail = parent.parent.document.getElementById("tabmail");
          let firstmessage;
          for each (let message in this.messages)
          {
            firstmessage = message;
            break;
          }
          tabmail.openTab("message", firstmessage.folderURI, firstmessage.folderMessage)
        } catch (e) {
           dumpExc(e, 'conversation');
        }
        ]]>
        </body>
      </method>
      <method name="_processSubThread">
        <parameter name="collection"/>
        <parameter name="node"/>
        <body>
        <![CDATA[
          collection.push(node);
          for each (let child in node['children'])
            this._processSubThread(collection, child);
        ]]>
        </body>
      </method>
      <method name="onItemsAdded">
        <body><![CDATA[
          try {
            let messagesUnsorted = this.messagesCollection.items;

            // XXX remove duplicates -- this should be replaced w/ a utility
            // function in Gloda
            // Thread the messages.
            // Make an array of phantoms so we don't end up modifying the actual
            // messages.
            let phantoms = [];
            for each (let [,item] in Iterator(messagesUnsorted)) {
              phantoms.push({__proto__: item});
            }

            let threadmap = new GlodaThreader('edge', 'children');
            let topnodes = threadmap.map(phantoms);
            let messages = [];
            for each (let [,topnode] in Iterator(topnodes))
            {
              this._processSubThread(messages, topnode);
            }
            this.messages = messages;
            
            let participants = {};
            let firstmessage = this.messages[0];

            if (! (firstmessage)) 
            {
              dump("ERROR: no message 0\n")
              return;
            }

            let originator = firstmessage.from;
            if (!originator) {
              dump("ERROR: from of first message is false\n");
              return;
            }

            // figure out participants, and add them
            // note: added in order of
            //   -  sender of first message is special (conversation originator)
            //   -  sender of subsequent messages (active speakers)
            //   -  then recipients (targets)
            //   -  then cc'ed (witnesses)
            participants[originator] = true;
            let authorNode = document.getAnonymousElementByAttribute(this, "anonid", "author");
            authorNode.glodaIdentity = originator;
            this.addParticipantNode('author', firstmessage.from, 'author');

            let oldestMessageDate = document.getAnonymousElementByAttribute(this, "anonid", "oldestMessageDate");
            // XXX hack to get the date for the conversation 
            //     oldestMessageDate isn't available in Gloda yet
            oldestMessageDate.textContent = makeDateFriendly( (this.conversation.oldestMessageDate)? 
                                                               this.conversation.oldestMessageDate : 
                                                               this.messages[this.messages.length - 1].date);

            let dateNode = document.getAnonymousElementByAttribute(this, "anonid", "date");
            dateNode.textContent = makeDateFriendly(firstmessage.date);
            
            let subjectNode = document.getAnonymousElementByAttribute(this, "anonid", "subject");
            subjectNode.textContent = this.conversation.subject;
            
            if (firstmessage.folderMessage) {
              this._message = firstmessage;
              parent.parent.MsgHdrToMimeMessage(firstmessage.folderMessage, this, this.addMessageBody)
            } else {
              dump("ERROR: Message from " + originator + " has no folderMessage\n");
            }

            let attachmentCount = 0;
            
            for each (let message in this.messages)
            {
              let sender = message.from;
              if (! (sender in participants))
              {
                participants[sender] = true;
                this.addParticipantNode('recipients', sender, "recipient speaker")
              }
              for each (let identity in message.to)
              {
                if (! (identity in participants))
                {
                  participants[identity] = true;
                  this.addParticipantNode('recipients', identity, "recipient")
                }
              }
              for each (let identity in message.cc)
              {
                if (! (identity in participants))
                {
                  participants[identity] = true;
                  this.addParticipantNode('recipients', identity, "recipient cc")
                }
              }
              if ( ! message.read ) 
                this.setAttribute("unread", "true"); /* conversation is unread */
                
              if ( message.attachmentNames ) {
                attachmentCount += firstmessage.attachmentNames.length;
                if ( attachmentCount > 0 ) {
                  let attachments = document.getAnonymousElementByAttribute(this, "anonid", "attachments");
                  attachments.textContent = attachmentCount.toString();
                  attachments.setAttribute("count", attachmentCount);
                }
              }
            }


            // find all the replies to this message, insert the ones that were
            // actually hit in the query itself.
            let hitMessageMap = document.getElementById('query').hitMessageMap;

            let messageIter = Iterator(this.messages);
            messageIter.next()
            let replies = document.getAnonymousElementByAttribute(this, "anonid", "replies");

            for each (let [i,replyMsg] in messageIter) {
              if (replyMsg.id in hitMessageMap)
              {
                let replyNode = document.createElement('reply');
                replies.appendChild(replyNode);
                replyNode.glodaMessage = replyMsg;
              }
            }
        } catch (e) {
           dumpExc(e, 'reply');
        }
        ]]></body>
      </method>
      <method name="onItemsModified">
        <body/>
      </method>
      <method name="onItemsRemoved">
        <body/>
      </method>
      <method name="onQueryCompleted">
        <body/>
      </method>
      
    </implementation>
    <content>
      <html:div class="checkbox" 
                onclick="event.stopPropagation();
                         document.getBindingParent(this).toggleSelectHelper();">
        <html:input anonid="checkbox" type="checkbox" tabindex="-1" 
                    onclick="event.stopPropagation();
                             document.getBindingParent(this).toggleSelect();"/>
      </html:div>
      <html:div class="target" onclick="document.getBindingParent(this).openConversationInTab();">
        <html:div class="header">
            <html:div class="meta">
              <html:div anonid="oldestMessageDate" class="oldestMessageDate"></html:div>
              <html:div anonid="attachments" class="attachments"></html:div>
            </html:div>
            <html:div anonid="subject" class="subject"></html:div>
            <html:div class="addressing">
              <html:span anonid="author" class="author"></html:span>
                <html:span anonid="verb" class="verb">writes</html:span>
                <html:div anonid="recipients" class="recipients"/> 
                <html:span anonid="date" class="date"></html:span>
            </html:div>
            <html:div anonid="tags" class="tags"></html:div>
        </html:div>
        <html:div anonid="snippet" class="body"></html:div>
      </html:div>
      <html:div class="replies" anonid="replies"></html:div>
    </content>  
  </binding>
  
  <binding id="message-in-conversation" extends="chrome://experimentaltoolbar/content/bindings.xml#message">
    <implementation>
      <field name="expanded">false</field>
      <method name="_update">
        <body>
        <![CDATA[
        try {
            parent.parent.MsgHdrToMimeMessage(this._message.folderMessage, this, this.addMessageBody)
            this.addParticipantNode('sender', this._message.from, 'sender');

            var dateNode = document.getAnonymousElementByAttribute(this, "anonid", "date");
            dateNode.textContent = makeDateFriendly(this._message.date);
            
            this.setAttribute("unread", !this._message.read);
            
            let attachmentCountNode = document.getAnonymousElementByAttribute(this, "anonid", "attachmentcount");
            let attachmentsList = document.getAnonymousElementByAttribute(this, "anonid", "attachments-list");
            let attachmentsNode = document.getAnonymousElementByAttribute(this, "anonid", "attachments");
            let attachmentsUL = document.getAnonymousElementByAttribute(this, "anonid", "attachment_ul");
            if (this._message.attachmentNames)
            {
              attachmentCountNode.textContent = '(' + this._message.attachmentNames.length.toString() + ')';
              for each (let attachmentName in this._message.attachmentNames)
              {
                let attachmentNode = document.createElement('li');
                let aref = document.createElement('a');
                aref.textContent = attachmentName;
                aref.setAttribute('href', attachmentName); // XXX
                attachmentNode.appendChild(aref);
                attachmentsUL.appendChild(attachmentNode);
              }
              $(attachmentsNode).show();
              $(attachmentsList).show();
            }
            else
            {
              $(attachmentsNode).hide();
              $(attachmentsList).hide();
            }
        } catch (e) {
           dumpExc(e, 'message');
        }
        ]]>
        </body>
      </method>
      <method name="_updateMsgBody">
        <body><![CDATA[
        try {
            var snippetNode = document.getAnonymousElementByAttribute(this, "anonid", "snippet");
            let content = parent.parent.Gloda.getMessageContent(this._message, this.mimeMsg);
            let snippet;
            if (content && content.hasContent())
              snippet = content.getContentSnippet(100);
            else
              snippet = findSnippetInMimeMsg(this.mimeMsg);
            if (!snippet)
              snippet = "";
            snippetNode.textContent = snippet;

            // the following should be replaced by a real mozilla text-to-html
            // converter XXX
            body = content.getContentString();
            let bodyHTML = makeHTML(body);
            
            let bodyDOM = stringToDOM(bodyHTML);
            let iframe = document.getAnonymousElementByAttribute(this, "anonid", "iframe");
            let bodyNode= iframe.contentDocument.body;
            try {
              bodyNode.appendChild(bodyDOM);
            } catch (e) {
              dumpExc(e);
            }
            if ($(this).hasClass("expanded"))
            {
              let iframe = document.getAnonymousElementByAttribute(this, "anonid", "iframe");
              let bodyNode= iframe.contentDocument.body;
              // XXX without this we have a scrollbar, i have no idea why.
              iframe.height = bodyNode.scrollHeight + 28;
            }
            this._message.domContribute(snippetNode);
            if (this._cb) this._cb();
        } catch (e) {
          dumpExc(e);
        }
        ]]>
        </body>
      </method>
      <method name="expand">
        <body>
          <![CDATA[
            $(this).addClass("expanded");
            this.expanded = true;
            let iframe = document.getAnonymousElementByAttribute(this, "anonid", "iframe");
            let bodyNode= iframe.contentDocument.body;
            iframe.height = bodyNode.scrollHeight + 28; // XXX?
          ]]>
        </body>
      </method>
      
      <method name="ensureVisible">
        <body>
          <![CDATA[
          try {
            // this needs to be in a timeout because the offsets won't be
            // correct until all the messages are laid out.
            let messageNode = this;
            window.setTimeout(function() {
              let toolbox = document.getElementById('conversation-contents').toolbox;
              let targetOffset = $(messageNode).offset().top - $(toolbox).height() - 10; // XXX constant
              $(document.getElementById('html')).animate( { scrollTop : targetOffset }, "fast" );
              $(messageNode).animate( { backgroundColor:"#ffffcc" }, { queue:true, duration:500 } )
                 .animate( { backgroundColor:"#ffffff" }, 500 );
            }, 200);
          } catch (e) {
            dumpExc(e);
          }
          ]]>
        </body>
      </method>
      <method name="reply">
        <body><![CDATA[
          try {
            let hdr = this._message.folderMessage;
            let messageUri = this._message.folderMessageURI;

            let type = Components.interfaces.nsIMsgCompType.ReplyToSender;
            let format = Components.interfaces.nsIMsgCompFormat.Default;

            let msgComposeService = Components.classes["@mozilla.org/messengercompose;1"].getService();
                msgComposeService = msgComposeService.QueryInterface(Components.interfaces.nsIMsgComposeService);

            let identity = msgComposeService.defaultIdentity;
            let msgWindow = Components.classes["@mozilla.org/messenger/msgwindow;1"].createInstance();
                msgWindow = msgWindow.QueryInterface(Components.interfaces.nsIMsgWindow);
            
            msgComposeService.OpenComposeWindow(null, hdr, messageUri, type, format, identity, msgWindow);

          } catch (e) {
            dumpExc(e);
          }
          ]]>
        </body>
      </method>
      <method name="replyAll">
        <body><![CDATA[
          try {
            let hdr = this._message.folderMessage;
            let messageUri = this._message.folderMessageURI;

            let type = Components.interfaces.nsIMsgCompType.ReplyAll;
            let format = Components.interfaces.nsIMsgCompFormat.Default;

            let msgComposeService = Components.classes["@mozilla.org/messengercompose;1"].getService();
                msgComposeService = msgComposeService.QueryInterface(Components.interfaces.nsIMsgComposeService);

            let identity = msgComposeService.defaultIdentity;
            let msgWindow = Components.classes["@mozilla.org/messenger/msgwindow;1"].createInstance();
                msgWindow = msgWindow.QueryInterface(Components.interfaces.nsIMsgWindow);
            
            msgComposeService.OpenComposeWindow(null, hdr, messageUri, type, format, identity, msgWindow);

          } catch (e) {
            dumpExc(e);
          }
          ]]>
        </body>
      </method>
      <method name="forward">
        <body><![CDATA[
          try {
            let hdr = this._message.folderMessage;
            let messageUri = this._message.folderMessageURI;

            /* there is a pref - mail.forward_message_mode that we aren't caring about */
            let type = Components.interfaces.nsIMsgCompType.ForwardInline;
            let format = Components.interfaces.nsIMsgCompFormat.Default;

            let msgComposeService = Components.classes["@mozilla.org/messengercompose;1"].getService();
                msgComposeService = msgComposeService.QueryInterface(Components.interfaces.nsIMsgComposeService);

            let identity = msgComposeService.defaultIdentity;
            let msgWindow = Components.classes["@mozilla.org/messenger/msgwindow;1"].createInstance();
                msgWindow = msgWindow.QueryInterface(Components.interfaces.nsIMsgWindow);
            
            msgComposeService.OpenComposeWindow(null, hdr, messageUri, type, format, identity, msgWindow);

          } catch (e) {
            dumpExc(e);
          }
          ]]>
        </body>
      </method>
    </implementation>
    <handlers>
      <handler event="click" phase="bubbling" preventdefault="true">
        <![CDATA[
        try {
          if (!this.expanded) {
            let conversation = document.getElementById('conversation-contents');
            conversation.selectMessage(this._message);
          }
        } catch (e) {
          dumpExc(e);
        }
        ]]>
      </handler>
    </handlers>
    <content><html:div class="header">
          <html:div class="headers">
            <html:div class="meta">
              <html:div>
                <html:span anonid="attachments" class="attachments">
                  <html:span anonid="attachmentcount" class="count"></html:span>
                  <html:img src="file:///usr/share/icons/gnome/16x16/status/stock_attach.png" />
                </html:span>
                <html:span anonid="date" class="time"></html:span>
              </html:div>
              <html:div class="actions">
                <html:button tabindex="-1" onclick="document.getBindingParent(this).reply()">reply</html:button>
                <html:button tabindex="-1" onclick="document.getBindingParent(this).replyAll()">reply all</html:button>
                <html:button tabindex="-1" onclick="document.getBindingParent(this).forward()">forward</html:button>
              </html:div>
            </html:div>
            <html:div class="details">
              <html:div class="participants"><html:span
                    anonid="sender" class="sender"></html:span></html:div
                ><html:div anonid="snippet" class="snippet"></html:div>
            </html:div>
          </html:div>
        </html:div>
        <html:div class="body">
          <html:div anonid="attachments-list" class="attachments-list">
            <html:div>attachments</html:div>
            <html:ul anonid="attachment_ul"></html:ul>
          </html:div>
          <html:iframe anonid="iframe" class="content" src="chrome://experimentaltoolbar/content/message.html"></html:iframe>
          <html:div class="attachments-area"></html:div>
          <html:div class="actions">
            <html:button tabindex="-1" onclick="document.getBindingParent(this).reply()">reply</html:button>
            <html:button tabindex="-1" onclick="document.getBindingParent(this).replyAll()">reply all</html:button>
            <html:button tabindex="-1" onclick="document.getBindingParent(this).forward()">forward</html:button>
          </html:div>
        </html:div></content>
  </binding>

  <binding id="threadnode" extends="chrome://experimentaltoolbar/content/bindings.xml#message">
    <!--this is an li of type='threadnode' -->
    <handlers>
      <handler event="click" phase="bubbling">
        <![CDATA[
        try {
          event.stopPropagation();
          let conversation = document.getElementById('conversation-contents');
          conversation.selectMessage(this.message); // this will select this threadnode
        } catch (e) {
          dumpExc(e);
        }
        ]]>
      </handler>
    </handlers>
    <implementation>
      <property name="glodaMessage">
        <!--This is the GlodaConversation object-->
        <getter>
            <![CDATA[
            return this.message;
            ]]>
        </getter>
        <setter>
        <![CDATA[
        try {
            this.message = val;

            let nameNode = document.getAnonymousElementByAttribute(this, 'anonid', 'span')
            nameNode.textContent = this.message.from.contact.name;

            this.setAttribute('unread', !this.message.read);
            
            if (this.message['children']) {
              let ulNode = document.createElement('ul');
              ulNode.setAttribute('class', 'thread');
              this.parentNode.appendChild(ulNode);
              for each (let child in this.message['children'])
              {
                let threadNode = document.createElement('li');
                threadNode.setAttribute('type', 'threadnode');
                threadNode.setAttribute('id', 'thread' + child.id.toString());
                threadNode.setAttribute('unread', !child.read);
                ulNode.appendChild(threadNode);
                threadNode.glodaMessage = child;
              }
            }

        } catch (e) {
          dumpExc(e);
        }
        ]]>
        </setter>
      </property>
      <method name="select">
        <body>
        <![CDATA[
        try {
          // do the CSS work for threadnode selection
          let conversation = document.getElementById('conversation-contents');
          let lastselected =  document.getAnonymousElementByAttribute(conversation, 'selected', 'true');
          if (lastselected)
          {
            lastselected.removeAttribute('selected');
            $(lastselected).removeClass('selected');
            $(lastselected).parent().removeClass('selected');
          }
          $(this).addClass("selected");
          $(this).parent().addClass("selected");
          this.setAttribute('selected', 'true');
        } catch (e) {
          dumpExc(e);
        }
        ]]>
        </body>
      </method>
    </implementation>
    <content>
      <html:span anonid="span" class="name"></html:span>
    </content>
  </binding>
  
  <binding id="conversation-reader" extends="chrome://experimentaltoolbar/content/bindings.xml#message">
    <implementation>
      <property name="glodaConversation">
        <!--This is the GlodaConversation object-->
        <getter>
            <![CDATA[
            return this.conversation;
            ]]>
        </getter>
        <setter>
        <![CDATA[
        try {
            this.conversation = val;
            this.expandedMessageIds = {};
            this.selectedMessage = null;
            this.messagesCollection =
              this.conversation.getMessagesCollection(this);
        } catch (e) {
          dumpExc(e);
        }
        ]]>
        </setter>
      </property>
      <property name="toolbox">
        <getter>
            <![CDATA[
            return document.getAnonymousElementByAttribute(this, 'anonid', 'toolbox');
            ]]>
        </getter>
      </property>
      <method name="expandMessages">
        <parameter name="messages"/>
        <body>
        <![CDATA[
        try {
          for each (let [,message] in Iterator(messages)) {
            let id = "msg" + message.id.toString();
            let messageNode =  document.getAnonymousElementByAttribute(this, 'id', id);
            if (messageNode) {
              messageNode.expand();
            }
            this.expandedMessageIds[message.id] = true;
          }
        } catch (e) {
           dumpExc(e, 'Exception in expandedMessages');
        }
        ]]>
        </body>
      </method>
      <method name="selectMessage">
        <parameter name="message"/>
        <parameter name="direct"/>  <!--Is this from user clicking on it?-->
        <body>
        <![CDATA[
        try {
          if (!message)
            return;

          if (direct == undefined) direct = false;

          let id = "msg" + message.id.toString();
          let messageNode =  document.getAnonymousElementByAttribute(this, 'id', id);

          if (messageNode) {
            messageNode.expand();
            if (!direct)
              messageNode.ensureVisible();
          }
          this.selectedMessage = message;

          // select the corresponding threadnode
          id = "thread" + message.id.toString();;
          let threadNode =  document.getAnonymousElementByAttribute(this, 'id', id);
          if (threadNode) 
            threadNode.select();
          
        } catch (e) {
           dumpExc(e, 'Exception in selectMessage');
        }
        ]]>
        </body>
      </method>
      <method name="addThreadNode">
        <parameter name="node"/>
        <parameter name="localparent"/>
        <body><![CDATA[
          try {
            let threadNode = document.createElement('li');
            threadNode.setAttribute('type', 'threadnode');
            threadNode.setAttribute('id', 'thread' + node.id.toString());
            localparent.appendChild(threadNode);
            threadNode.glodaMessage = node;
          } catch (e) {
            dumpExc(e);
          }
          ]]>
        </body>
      </method>
      <field name="_setterQueue">[]</field>
      <method name="_tweakQueue">
        <body><![CDATA[
          try {
            // we have a queue of setters, because if we set all messages
            // in a long conversation at once, sqlite ends up hammered,
            // and gloda is unable to optimize things like identity management
            // so this makes them happen one after the other.  much faster
            // response.
            if (this._setterQueue.length == 0) return;
            let front = this._setterQueue[0];
            this._setterQueue = this._setterQueue.slice(1);
            let node = front[0];
            let message = front[1];
            let self = this;
            let cb = function () { self._tweakQueue() };
            node._cb = cb;
            node.glodaMessage = message; // this will call the cb when it's done.
          } catch (e) {
            dumpExc(e);
          }
          ]]>
        </body>
      </method>
      
      <method name="addMessageNode">
        <parameter name="node"/>
        <parameter name="queue"/>
        <body><![CDATA[
          try {
            let messagesNode = document.getAnonymousElementByAttribute(this, "anonid", "messages");
            let messageNode = document.createElement("message-in-conversation");
            messagesNode.appendChild(messageNode);
            if (!queue) {
              messageNode.glodaMessage = node;
            } else {
              this._setterQueue.push([messageNode, node])
              this._tweakQueue();
            }
            if (node.id in this.expandedMessageIds) {
              messageNode.expand();
            }
            this.messageNode = messageNode;
            for each (let child in node['children'])
            {
              this.addMessageNode(child, queue)
            }
          } catch (e) {
            dumpExc(e);
          }
          ]]>
        </body>
      </method>
      <method name="onItemsAdded">
        <body><![CDATA[
          try {
            this.messages = this.messagesCollection.items;
            
            let subjectNode = document.getAnonymousElementByAttribute(this, "anonid", "subject");
            subjectNode.textContent = this.conversation.subject;
            
            // XXX remove duplicates -- this should be replaced w/ a utility
            // function in Gloda
            // Thread the messages.
            // Make an array of phantoms so we don't end up modifying the actual
            // messages.
            let phantoms = [];
            for each (let [,item] in Iterator(this.messages)) {
              phantoms.push({__proto__: item});
            }

            let threadmap = new GlodaThreader('edge', 'children');
            let topnodes = threadmap.map(phantoms);
            for each (let [,topnode] in Iterator(topnodes))
            {
              this.addThreadNode(topnode, document.getAnonymousElementByAttribute(this, "anonid", "threadroot"));
              this.addMessageNode(topnode, true); // queue, as these can be slow.
            }

            if (this.selectedMessage)
            {
              let id = "thread" + this.selectedMessage.id.toString();
              let threadNode = document.getAnonymousElementByAttribute(this, "id", id);
              if (threadNode)
                threadNode.select();

              id = "msg" + this.selectedMessage.id.toString();
              let messageNode = document.getAnonymousElementByAttribute(this, "id", id);
              if (messageNode) {
                messageNode.ensureVisible();
              }
            }
            
            let firstmessage = topnodes[0];
            let participants = {};
            this.addParticipantNode('participants', firstmessage.from, "recipient from")
            participants[firstmessage.from] = true;
            for each (let message in phantoms)
            {
              let sender = message.from;
              if (! (sender in participants))
              {
                participants[sender] = true;
                this.addParticipantNode('participants', sender, "recipient from")
              }
              for each (let identity in message.to)
              {
                if (! (identity in participants))
                {
                  participants[identity] = true;
                  this.addParticipantNode('participants', identity, "recipient to")
                }
              }
              for each (let identity in message.cc)
              {
                if (! (identity in participants))
                {
                  participants[identity] = true;
                  this.addParticipantNode('participants', identity, "recipient cc")
                }
              }
            }            
            this.positionFixedElements();
            let creader = this;
            $(window).resize(function() {
              creader.positionFixedElements();
            });
        } catch (e) {
           dumpExc(e, 'reply');
        }
        ]]></body>
      </method>
      <method name="onItemsModified">
        <body/>
      </method>
      <method name="onItemsRemoved">
        <body/>
      </method>
      <method name="onQueryCompleted">
        <body/>
      </method>
      <method name="positionFixedElements">
        <body><![CDATA[
          try {
            let toolboxNode = document.getAnonymousElementByAttribute(this, "anonid", "toolbox");
            $(toolboxNode).width($(this).width());
            let top = ($(toolboxNode).height() + 10);  // XXX constant
            let threaderNode = document.getAnonymousElementByAttribute(this, "anonid", "threader");
            $(threaderNode).css("top", top);
            
            let conversationNode = document.getAnonymousElementByAttribute(this, "anonid", "conversation");
            $(conversationNode).css("top", top);
          } catch (e) {
            dumpExc(e);
          }
          ]]>
        </body>
      </method>
    </implementation>
    <content>
      <html:div anonid="toolbox" class="toolbox">
        <html:div class="toolbar">
          <!--<html:button style="font-weight:bold;">Archive</html:button>-->
          <html:button tabindex="-1" onclick="document.getBindingParent(this).junkSelectedConversations()">Junk</html:button>
          <html:button tabindex="-1" onclick="document.getBindingParent(this).deleteSelectedConversations()">Delete</html:button>
        </html:div>
        <html:div anonid="subject" class="subject"></html:div>
        <html:div class="between">Between <html:span anonid="participants" class="recipients"></html:span>
        </html:div>
      </html:div>
      <html:div anonid="threader" class="threader">
        <html:ul anonid="threadroot" class="thread top"></html:ul>
        <html:div style="font-size:x-small;margin-top:2em;">
          <html:div><html:a id="expandAll" href="javascript:void(0);">Expand All</html:a></html:div>
          <html:div><html:a id="collapseAll" href="javascript:void(0);">Collapse All</html:a></html:div>
        </html:div>
      </html:div>
      <html:div anonid="conversation" class="main">
        <html:div anonid="messages" class="messages"/>
      </html:div>
    </content>
  </binding>
</bindings>
